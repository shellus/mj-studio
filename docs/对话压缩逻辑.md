# 对话压缩逻辑

## 概述

当对话历史过长时，通过 AI 生成摘要来压缩上下文，减少后续请求的 token 消耗，同时保留完整的历史记录供用户查看。

## 核心概念

- **压缩保留消息数**：压缩时保留的最近消息数量（常量，如 4 条）
- **压缩请求**：用户发起的压缩指令消息，`mark = 'compress-request'`
- **压缩响应**：AI 生成的摘要消息，`mark = 'compress-response'`
- **压缩边界**：压缩响应的位置，决定后续请求的上下文起点

## 压缩流程

### 示例场景

假设当前有 100 条消息（50 条用户 + 50 条 AI），压缩保留消息数 = 4。

### 步骤 1：计算压缩范围

```
待压缩消息数 = 总消息数 - 压缩保留消息数
             = 100 - 4
             = 96 条
```

消息分布：
- 第 1-96 条：待压缩的历史消息
- 第 97-100 条：保留的最近消息

### 步骤 2：创建压缩请求消息

在第 96 条之后插入压缩请求消息：
- `role = 'user'`
- `mark = 'compress-request'`
- 内容为压缩指令（固定文本）

```
请将以上对话内容压缩为一份简洁的摘要，包含：
1. 讨论的主要话题
2. 达成的结论或决定
3. 重要的上下文信息
```

此时消息顺序：
- 第 1-96 条：待压缩的历史消息
- 第 97 条：压缩请求（`mark = 'compress-request'`）
- 第 98-101 条：原第 97-100 条消息

### 步骤 3：请求 AI 生成摘要

构造请求：
1. 发送第 1-96 条消息（保持原有格式，利用 API 缓存）
2. 发送第 97 条压缩请求消息

### 步骤 4：流式响应

- 压缩请求消息显示在对话界面（特殊样式）
- AI 回复流式渲染，与普通消息一致
- 用户可点击停止按钮中断压缩

### 步骤 5：保存压缩响应

AI 回复完成后：
1. 将压缩响应保存到数据库
   - `role = 'assistant'`
   - `mark = 'compress-response'`
2. 压缩响应插入位置：第 97 条之后（即第 98 位）

最终消息顺序：
- 第 1-96 条：历史消息（保留，但后续不发送给 AI）
- 第 97 条：压缩请求（`mark = 'compress-request'`）
- 第 98 条：压缩响应（`mark = 'compress-response'`）
- 第 99-102 条：原第 97-100 条消息

### 步骤 6：UI 展示

- 压缩请求：显示特殊样式（如蓝色边框 + 压缩图标）
- 压缩响应：默认**折叠状态**，点击展开查看完整摘要
- 压缩请求前显示分界线："以上内容已压缩"
- 支持删除压缩请求/响应消息

## 后续对话逻辑

### 构建请求上下文

当用户发送新消息时：

1. 查找最后一个压缩响应（`mark = 'compress-response'`）
2. 从该压缩响应开始，获取其后的所有消息
3. 加上用户新输入，构成完整请求

### 示例

压缩后用户发送新消息：
```
请求内容 = [
  第 98 条（压缩响应）,
  第 99-102 条（保留的消息）,
  用户新输入
]
共 6 条消息
```

注意：压缩请求（`compress-request`）不发送给 AI，只发送压缩响应作为上下文起点。

### 多次压缩

每次压缩都从上一个压缩响应开始，形成"摘要的摘要"：

**第一次压缩**（100 条消息）：
- 发送：第 1-96 条 + 压缩请求
- 结果：压缩响应包含 1-96 条的摘要

**第二次压缩**（假设又积累了 50 条，共 152 条）：
- 发送：第一次压缩响应 + 第 99-148 条 + 压缩请求
- 结果：新压缩响应包含"第一次摘要 + 后续对话"的摘要

这种方式：
- ✅ 利用 API 缓存（上次压缩响应已缓存）
- ✅ 避免重复发送原始历史
- ⚠️ 多次压缩后可能丢失细节（摘要的摘要）

## 数据库设计

### messages 表

| 字段 | 类型 | 说明 |
|-----|------|------|
| id | INTEGER | 主键，自增 |
| sortId | INTEGER | 排序 ID，决定消息显示顺序 |
| mark | TEXT | 消息标记：`null`（普通）、`'error'`（错误）、`'compress-request'`（压缩请求）、`'compress-response'`（压缩响应） |

### sortId 说明

- 普通消息：`sortId = id`（创建时自动设置）
- 压缩请求：`sortId` 设为待压缩消息的最后一条的 `sortId + 1`
- 压缩响应：`sortId` 设为压缩请求的 `sortId + 1`
- 保留消息：压缩后需更新 `sortId`，确保在压缩响应之后

### 示例

压缩前（100 条消息）：
```
id=1,  sortId=1   (消息1)
id=2,  sortId=2   (消息2)
...
id=96, sortId=96  (消息96)
id=97, sortId=97  (消息97)
...
id=100, sortId=100 (消息100)
```

压缩后：
```
id=1,   sortId=1   (消息1)
...
id=96,  sortId=96  (消息96)
id=101, sortId=97  (压缩请求) ← 新插入
id=102, sortId=98  (压缩响应) ← 新插入
id=97,  sortId=99  (原消息97) ← sortId 更新
id=98,  sortId=100 (原消息98) ← sortId 更新
id=99,  sortId=101 (原消息99) ← sortId 更新
id=100, sortId=102 (原消息100) ← sortId 更新
```

### 查询逻辑

```sql
-- 获取对话上下文：从最后一个 compress-response 消息开始
SELECT * FROM messages
WHERE conversation_id = ?
  AND sortId >= COALESCE(
    (SELECT MAX(sortId) FROM messages WHERE conversation_id = ? AND mark = 'compress-response'),
    0
  )
  AND mark != 'compress-request'  -- 排除压缩请求
ORDER BY sortId ASC
```

### 删除压缩消息的处理

当压缩响应被删除时，系统自动回退到上一个压缩点：
- 查找前一个 `compress-response`，从那里开始构建上下文
- 如果没有前一个压缩点，则发送所有历史消息

## 配置常量

```typescript
// server/services/conversation.ts
export const COMPRESS_KEEP_COUNT = 4  // 压缩时保留的最近消息数
```

## UI 交互

### 触发压缩

- 输入框上方显示对话大小统计
- 超过阈值时显示"压缩对话"按钮
- 点击后开始压缩流程

### 压缩中状态

- 压缩请求消息立即显示在对话中
- AI 摘要流式输出（与普通消息一致）
- 可点击停止按钮中断压缩

### 消息样式

| mark | 样式 |
|------|------|
| `compress-request` | 蓝色边框 + 压缩图标，前有分界线 |
| `compress-response` | 琥珀色边框 + 文档图标，默认折叠 |

### 压缩完成

- 压缩响应默认折叠，点击展开
- 分界线标识压缩边界（显示在压缩请求前）
- 用户可删除压缩请求/响应（会影响后续上下文）
