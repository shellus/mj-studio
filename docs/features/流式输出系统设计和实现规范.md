# 流式输出系统设计和实现规范

本文档描述 MJ Studio 聊天功能的流式输出架构设计，供开发者理解系统设计和实现规范。

## 术语表

| 术语 | 定义 |
|------|------|
| AI 消息 | 由 AI 生成的回复消息（数据库中 role = assistant） |
| 流式输出 | 内容逐块生成并传输，而非等待完整生成后一次性返回 |
| SSE | Server-Sent Events，服务端向客户端推送事件的技术 |
| 流式缓存 | 内存中缓存流式输出过程中的内容，用于刷新恢复 |
| 上游 | 提供 LLM 服务的 API 端点 |

## 产品特性

### 实时响应
- AI 回复逐字显示，无需等待完整生成
- 打字机效果增强阅读体验

### 可中断
- 用户可随时停止生成
- 已输出内容保留，不会丢失

### 刷新恢复
- 页面刷新后自动恢复进行中的流式输出
- 无需重新发起请求

### 错误友好
- 生成失败时错误信息直接显示在对话中
- 错误消息持久化，刷新后仍可见

## 架构设计

```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│    浏览器     │   SSE   │   后端服务    │   SSE   │     上游     │
│              │◄────────│              │◄────────│              │
│  打字机渲染   │         │  转发 + 缓存  │         │  流式生成     │
└──────────────┘         └──────────────┘         └──────────────┘
                                │
                                ▼
                         ┌──────────────┐
                         │   流式缓存    │
                         │   (内存)     │
                         └──────────────┘
```

### 三层职责

| 层级 | 职责 |
|------|------|
| 上游 | 流式生成 AI 回复内容 |
| 后端服务 | 转发流式数据、维护流式缓存、持久化消息 |
| 浏览器 | 消费流式数据、打字机渲染、状态管理 |

## 消息模型

### 消息状态 (`status`)

AI 消息的 `status` 字段用于追踪生成状态：

| 状态 | 含义 | UI 表现 |
|------|------|---------|
| `created` | 已创建，尚未发起请求 | 显示加载动画 |
| `pending` | 已发起上游请求，等待响应 | 显示加载动画 |
| `streaming` | 已收到首字，正在接收中 | 显示打字机 + 停止按钮 |
| `completed` | 生成完成 | 正常显示 |
| `stopped` | 用户中断 | 显示已中断标记 |
| `failed` | 生成失败 | 显示错误样式 |

**前端渲染规则**：
- `created` / `pending` → 加载动画（转圈）(可以渲染为不同的loading状态用户反馈更友好)
- `streaming` → 打字机效果 + 停止按钮
- `completed` / `stopped` / `failed` → 静态显示

### 消息类型 (`mark`)

`mark` 字段用于标记消息的业务类型：

| 类型 | 含义 |
|------|------|
| `null` | 普通消息 |
| `compress-request` | 压缩请求 |
| `compress-response` | 压缩摘要 |
| `error` | 错误消息（内容为错误信息） |

### 状态与类型分离

- `status` 描述消息的**生命周期状态**（是否完成）
- `mark` 描述消息的**业务类型**（什么类型的消息）
- 两者正交，互不影响

**示例**：
- `status: failed, mark: error` → 生成失败，内容是错误信息
- `status: completed, mark: compress-response` → 压缩完成，内容是摘要

## 前后端解耦

### 核心原则

**后端是独立的状态机，不依赖前端连接。**

- POST 创建消息后，后端立即开始请求上游
- 无论前端是否订阅 SSE，后端都会完成整个流程
- 状态流转和内容生成完全在后端自主完成
- SSE 只是订阅机制，不影响后端行为

### 解耦带来的能力

| 前端行为 | 后端行为 | 结果 |
|----------|----------|------|
| 立即订阅 SSE | 正常生成 | 实时看到流式输出 |
| 延迟订阅 SSE | 正常生成 | 从流式缓存补发已生成内容 |
| 从不订阅 | 正常生成 | 刷新后看到完整消息 |
| 中途断开 | 继续生成 | 重连后继续接收 |
| 发完消息就关闭浏览器 | 继续生成 | 下次打开看到结果 |

## 数据流

### 后端流程（独立运行）

```
POST /api/conversations/:id/messages
      │
      ▼
创建用户消息 + AI 消息（status: created）
      │
      ▼
返回两个消息 ID，HTTP 响应结束
      │
      ▼
异步：发起上游请求，更新 status: pending
      │
      ▼
异步：收到首个内容块，更新 status: streaming，写入流式缓存
      │
      ▼
异步：持续接收，逐块写入流式缓存
      │
      ▼
异步：流结束，更新 content + status: completed，清理流式缓存
```

### 前端流程（独立运行）

```
发送 POST 请求
      │
      ▼
收到两个消息 ID
      │
      ▼
显示两条消息，AI 消息为 created 状态（加载动画）
      │
      ▼
订阅 GET /api/messages/:id/stream（SSE）
      │
      ▼
接收流式内容，打字机效果渲染
      │
      ▼
收到 done 信号，结束
```

### 刷新恢复流程

```
加载消息列表
      │
      ▼
发现 AI 消息 status 为 created/pending/streaming
      │
      ▼
订阅 GET /api/messages/:id/stream（SSE）
      │
      ▼
后端返回数据（从流式缓存或数据库）
      │
      ▼
继续打字机渲染
```

### 中断流程

```
用户点击停止
      │
      ▼
POST /api/messages/:id/stop
      │
      ▼
后端中止上游请求
      │
      ▼
更新 status: stopped，将流式缓存内容写入数据库，清理流式缓存
      │
      ▼
如有 SSE 订阅者，发送 done 信号
```

### 错误流程

```
上游返回错误
      │
      ▼
后端更新 status: failed，mark: error，content 设为错误信息
      │
      ▼
清理流式缓存
      │
      ▼
如有 SSE 订阅者，发送 error + done 信号
```

## 消息 ID 提前生成

### 设计要点

用户发消息时同时创建 AI 消息，前端始终持有真实消息 ID。

### 好处

1. **操作可靠**：停止/删除操作基于真实 ID
2. **状态明确**：通过数据库 `status` 字段判断消息状态
3. **刷新友好**：刷新后直接查数据库状态
4. **简化前端**：无需维护临时 ID 映射逻辑

## 流式缓存

仅用于缓存流式输出过程中的内容，支持页面刷新后恢复。

### 缓存内容
- 消息 ID（作为 key）
- 已累积的流式内容
- 最后更新时间

### 生命周期
- **创建**：收到首个内容块时
- **更新**：每收到一块内容时追加
- **删除**：流式结束时（无论成功/失败/中断）

**重要原则**：流式缓存内容在任何终止场景下都必须先写入数据库再清理缓存，包括：
- 正常完成（status: completed）
- 用户中断（status: stopped）
- 上游错误（status: failed）
- 连接超时（status: failed）
- 其他异常（status: failed）

### 与数据库的关系

| 数据 | 存储位置 | 用途 |
|------|----------|------|
| 消息状态 | 数据库 `status` 字段 | 持久化状态 |
| 最终内容 | 数据库 `content` 字段 | 持久化内容 |
| 流式中间内容 | 流式缓存 | 刷新恢复 |

## API 设计

### 发送消息

```
POST /api/conversations/:id/messages
Body: { content: "用户消息" }
Response: { userMessageId: 123, assistantMessageId: 124 }
```

创建消息后立即返回，后端异步开始生成。

### 订阅流式输出

```
GET /api/messages/:id/stream
Response: SSE 流
```

订阅指定 AI 消息的流式输出：
- 如果消息正在生成（status 为 created/pending/streaming）：保持连接，从流式缓存补发已生成内容，继续推送后续内容
- 如果消息已完成（status 为 completed/stopped/failed）：从数据库取出完整内容，以 SSE 格式返回后结束

**多订阅者支持**：同一消息可被多个客户端订阅（多标签页、多设备），后端通过发布-订阅模式广播：
- 维护「消息 ID → SSE 连接列表」映射
- 状态变更或新内容块时，向该消息的所有订阅者广播

### 停止生成

```
POST /api/messages/:id/stop
Response: { success: true }
```

中止生成，将流式缓存内容写入数据库，清理流式缓存，停止接收上游输出。

**权限校验**：只有消息所属用户能停止

**状态校验**：
- 只有 `created`/`pending`/`streaming` 状态能停止
- 对已完成消息（`completed`/`stopped`/`failed`）调用：返回成功但不做任何操作（静默忽略）

## 消息协议（SSE）

所有 SSE 消息使用统一格式。

### 内容块

```json
{"content": "Hello", "done": false}
{"content": " world", "done": false}
```

### 流结束

```json
{"done": true, "status": "completed"}
{"done": true, "status": "stopped"}
{"done": true, "status": "failed"}
```

前端根据 `status` 字段更新消息状态。

### 错误

```json
{"error": "API 请求失败", "done": true, "status": "failed"}
```

## 打字机效果

前端不直接显示收到的内容，而是通过打字机效果逐字渲染：

- **缓冲区**：收到的内容先进入缓冲区
- **渲染速度**：每 15ms 渲染 3 个字符
- **立即显示**：流结束/中断/出错时立即显示全部内容

## 边界情况处理

| 场景 | 处理方式 |
|------|----------|
| 网络断开 | 后端继续生成，前端重连后从流式缓存恢复 |
| 上游错误 | 更新 status: failed，mark: error，content 设为错误信息 |
| 用户主动停止 | 更新 status: stopped，保存已生成内容 |
| 页面刷新 | 根据数据库 status 判断，订阅 SSE 恢复 |
| 流式缓存超时 | 将已接收内容写入数据库，更新 status: failed，清理缓存 |
| 并发请求 | 每条消息独立缓存，互不影响 |
| 订阅已完成消息 | 从数据库取完整内容，以 SSE 格式返回 |

## 数据库变更

### messages 表新增字段

```sql
ALTER TABLE messages ADD COLUMN status TEXT;
```

### 状态值

- `created` - 已创建
- `pending` - 已发起请求
- `streaming` - 正在接收
- `completed` - 生成完成
- `stopped` - 用户中断
- `failed` - 生成失败

### 兼容性

- 用户消息 `status` 为 `null`（无需状态）
- 历史 AI 消息 `status` 为 `null`，数据库迁移时设置为 `completed`
