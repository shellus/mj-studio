# 全局事件订阅系统设计（Global SSE）

本文档基于当前项目已落地的 SSE 能力（对话按 `messageId` 订阅、工作流按 `runId` 订阅），给出一个“**用户级全局订阅**”的可落地方案，并明确一期（第一期）只覆盖的能力与迁移边界，避免在需求/设计阶段给实现挖坑。

## 1. 背景与现状

### 1.1 现有 SSE 形态（已实现）

- 对话流式输出：`GET /api/messages/:id/stream`（按 **messageId** 建立 SSE 连接），后端通过 `streamingCache` 维护 `messageId -> subscribers` 广播流式 chunk。（**一期将被全局 SSE 方案替换并移除**）
- 工作流实时状态：`GET /api/workflow-runs/:runId/events`（按 **runId** 建立 SSE 连接），后端通过 `workflowRun` 维护 `runId -> subscribers` 广播事件。
- 前端为了携带 JWT，使用 `fetch + ReadableStream` 自行解析 SSE（而不是 `EventSource`）。

### 1.2 当前问题

1. **多端/多标签页同步能力不足**：对话“新消息出现”主要依赖请求响应后的本地渲染，其他终端/标签页不会自动出现新消息。
2. **连接粒度过细**：流式输出需要每条 AI 消息单独订阅（`messageId` 维度），当需要同时同步多个事件源时，连接数量会上升。
3. **未来能力无法承载**：`[依赖全局订阅] 助手共享/会话共享/多人参与对话` 需要“按用户/会话广播”的基础设施，而不是“按某个任务/某条消息订阅”。

## 2. 目标与边界

### 2.1 目标（必须落地）

- **全局 SSE**：用户登录后，每个浏览器页面启动 **1 条** SSE 订阅（用户级），用于接收该用户的全局事件。
- **用户维度广播**：向 `userId` 广播时，该用户的 **所有终端/所有标签页** 都能收到。
- **一期范围**：仅在以下两类场景完成事件化渲染：
  - 对话消息新增（user/assistant 消息的创建）
  - AI 消息流式输出（chunk 下发 + done/error）
- **为后续扩展预留**：事件路由/协议需能扩展到“会话共享/多人参与对话”，但一期不要求实现多人会话的权限与成员体系。

### 2.2 非目标（一期不做，但不阻碍后续）

- 不在一期把所有 UI 状态都改为事件驱动（如对话创建/删除、消息编辑/删除、对话标题更新等）。
- 不在一期实现“完整可靠的服务端事件重放”（基于 `Last-Event-ID` 的持久化补发）。一期采用“**SSE 负责实时、REST 负责对账**”的方式保证一致性。
- 不在一期引入跨实例广播组件（如 Redis Pub/Sub、消息队列）；一期按单实例内存 Hub 落地，后续再演进。

## 3. 总体方案

新增一个全局事件流端点：

```
GET /api/events
```

- 连接粒度：**userId**
- 服务端维护：`userId -> Set<SSEConnection>`
- 事件产出点：
  - `server/api/conversations/[id]/messages.post.ts`：创建用户消息 + 创建 AI 消息后广播“消息新增”
  - `server/services/streamingTask.ts`：流式生成过程中广播 chunk / done / error
- 客户端：登录后建立全局订阅，收到事件后更新本地 store；一期只处理“消息新增 + AI 流式”相关事件，其余事件先忽略。

## 4. SSE 协议与事件模型

### 4.1 SSE 基本格式

全局事件流使用标准 SSE 字段：

```
id: <eventId>
event: <eventType>
data: <json>

```

服务端必须设置（与现有 SSE 接口保持一致）：

- `Content-Type: text/event-stream`
- `Cache-Control: no-cache`
- `Connection: keep-alive`
- `X-Accel-Buffering: no`（避免 Nginx 缓冲导致延迟，项目 `README.md` 已有相关说明）

同时建议发送心跳以保持连接：

```
: ping

```

### 4.2 事件包络（Envelope）

为避免后续扩展时协议碎片化，建议所有事件 `data` 使用统一包络：

```ts
type GlobalEventEnvelope<T> = {
  id: string
  ts: number            // Date.now()
  type: string          // 与 SSE event 字段保持一致
  data: T
}
```

一期实现可直接使用 `id = ulid/uuid`，或简单的自增序列（仅要求在单进程内唯一即可）。若后续要支持 `Last-Event-ID` 补发，再引入“按用户的环形缓冲 + 持久化/Redis”。

### 4.3 一期事件清单（可直接编码）

#### A) 对话消息新增：`chat.message.created`

触发时机：消息写入数据库成功后（用户消息、AI 消息都会触发）。

`data`：

```ts
type ChatMessageCreated = {
  conversationId: number
  message: {
    id: number
    conversationId: number
    role: 'user' | 'assistant'
    content: string
    files: any[] | null
    status: 'created' | 'pending' | 'streaming' | 'completed' | 'stopped' | 'failed' | null
    mark: string | null
    sortId: number | null
    createdAt?: string
    updatedAt?: string
  }
}
```

约束：
- 前端按 `message.id` 做 upsert，避免多端/重连/重复触发导致重复插入。

#### B) AI 流式 chunk：`chat.message.delta`

触发时机：`streamingTask` 收到上游 chunk 并写入缓存后。

`data`：

```ts
type ChatMessageDelta = {
  conversationId: number
  messageId: number
  delta: string
}
```

约束：
- 一期不要求 chunk 可靠补发；若客户端丢 chunk，依赖对账（重新拉取消息列表/消息详情）恢复最终一致性。

#### C) AI 流式结束：`chat.message.done`

触发时机：`streamingTask` 结束（completed/stopped/failed）。

`data`：

```ts
type ChatMessageDone = {
  conversationId: number
  messageId: number
  status: 'completed' | 'stopped' | 'failed'
  error?: string

  // 复用现有实现：首字耗时回写模型配置
  estimatedTime?: number
  upstreamId?: number
  aimodelId?: number
}
```

约束：
- done 事件必须能“单独驱动 UI 结束态”，不依赖请求响应返回。

## 5. 后端落地设计

### 5.1 新增：全局事件 Hub（内存版）

新增服务：`server/services/globalEvents.ts`（建议命名），提供最小可用能力：

- `addUserSubscriber(userId, event)`：注册 SSE 连接
- `removeUserSubscriber(userId, event)`：移除连接
- `emitToUser(userId, eventType, envelope)`：向该用户所有连接广播
- `emitToUsers(userIds, ...)`：为“多人会话”预留（一期可以先不暴露或仅内部使用）

实现要点（与现有 `streamingCache/workflowRun` 的模式保持一致）：
- 内部维护 `Map<number, Set<{ event: H3Event }>>`
- `res.write()` 失败时立即从集合移除，避免内存泄漏
- 由 SSE handler 监听 `req.close/error` 触发 remove
- 可选：定时心跳（建议在 SSE handler 内实现，便于生命周期绑定）

### 5.2 新增：全局 SSE 端点

新增接口文件：`server/api/events.get.ts`

- 鉴权：`requireAuth(event)`（支持 header；若客户端使用 `EventSource`（无法自定义 header），可使用 query `?token=...`，项目 `server/utils/jwt.ts` 已支持）
- 返回：保持连接并持续写入 SSE
- 连接建立时可先发送一次 `hello`（便于前端确认连通）：
  - `event: system.hello`
  - `data: { userId, ts }`

### 5.3 一期接入点（两处改动即可）

#### A) 消息新增事件

改动点：`server/api/conversations/[id]/messages.post.ts`

- 创建用户消息成功后：向 `user.id` 广播 `chat.message.created`
- 创建 AI 消息成功后：向 `user.id` 广播 `chat.message.created`
- 压缩请求路径（`isCompressRequest`）下也需保证 AI 消息创建事件会广播

#### B) 流式事件

改动点：`server/services/streamingTask.ts`

- 收到 chunk：广播 `chat.message.delta`
- 结束/错误：广播 `chat.message.done`
- 一期不再通过 `messageId` 维度 SSE 下发：删除/下线 `/api/messages/:id/stream`，并移除对应的 per-message subscribers 广播路径，避免“双通道”导致语义不一致与测试成本上升。

## 6. 前端落地设计（一期）

### 6.1 全局订阅启动时机

- 登录成功后，在应用生命周期内保持 1 条连接（每个页面 1 条）。
- Nuxt 建议位置：
  - `app/plugins/global-events.client.ts`（仅 client 运行）
  - 或在根布局组件中监听登录态变化后启动/重连

### 6.2 订阅方式

沿用项目现有实践：使用 `fetch` 订阅 SSE，携带 `Authorization` header（避免 token 暴露在 URL）。

建议把“解析 SSE”抽成可复用工具（对话流式、工作流 SSE、全局 SSE 共用），避免各处复制解析逻辑。

### 6.3 一期事件处理策略

只处理第 4.3 节事件，其余 `event` 直接忽略即可。

- `chat.message.created`：
  - 若当前已加载该 `conversationId` 的消息列表：按 `message.id` upsert 到 `messages`。
  - 若未加载：可忽略（后续用户进入对话时通过 REST 拉取对账）。
- `chat.message.delta`：
  - 找到 `messageId` 对应消息并追加内容（可复用现有“打字机缓冲”机制）。
  - 若消息不存在：忽略（对账时会拿到完整内容）。
- `chat.message.done`：
  - 更新消息状态为 `completed/stopped/failed`。
  - 若携带 `estimatedTime/upstreamId/aimodelId`，复用现有逻辑同步更新 upstreams 状态。

### 6.4 一期替换策略（不做兼容/降级）

- 一期直接将“对话消息新增 + AI 流式输出”的 UI 驱动方式切换为全局 SSE（`GET /api/events`），不保留 `/api/messages/:id/stream` 作为兼容通道。
- `POST /api/conversations/:id/messages` 仍可返回 `{ userMessageId, assistantMessageId }` 用于调用方关联与排障，但前端渲染以 SSE 事件为准（不再依赖响应体来插入/追加消息内容）。

## 7. 迁移计划（分期可验收）

### 第 0 阶段：基础设施（无 UI 变更）

- 后端：加 `/api/events` + `globalEvents` service，但不发业务事件或仅发 `system.hello`。
- 前端：建立连接并打印日志（不驱动 UI）。

验收：登录后能稳定保持连接，重连正常，Nginx 代理下无缓冲延迟。

### 第 1 阶段：对话“消息新增 + 流式输出”事件化（本需求范围）

- 后端：按第 5.3 节在两处发事件。
- 前端：按第 6.3 节消费事件，完成多端同步。
- 清理旧实现：移除 `/api/messages/:id/stream` 以及前端按 messageId 建连的订阅逻辑。

验收：
- A 端发送消息，B 端同一用户在线时能看到新消息出现。
- A 端触发 AI 流式，B 端能实时看到 delta 增量与最终 done。

### 第 2 阶段：更多事件渲染（后续）

按同一机制扩展：
- 对话创建/删除/标题更新
- 消息删除/编辑/重放/分叉
- 工作流/任务事件统一纳入全局 SSE（可选）

## 8. 风险与约束（落地时需要明确）

- **代理缓冲**：必须确保 `X-Accel-Buffering: no`，且 Nginx 配置 `proxy_buffering off`（已有文档约束）。
- **事件乱序/重复**：客户端必须 upsert，并以 `sortId`（或 `id`）排序渲染；done/delta 需允许重复处理（幂等）。
- **服务端内存模型**：一期 `Map<userId, Set<conn>>` 仅适用于单进程/单实例；若需要多实例部署，后续需引入 Redis Pub/Sub 或消息队列做跨实例广播。
- **丢事件的处理**：一期不做服务端补发，依赖“页面进入/刷新时 REST 拉取对账”保证最终一致性。
